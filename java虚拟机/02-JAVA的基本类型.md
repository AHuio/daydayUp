---
typora-root-url: ..\image
---

**Part2：JAVA的基本数据类型**

​	JAVA语言有八大基本类型，JAVA这麽做的原因主要是工程上的考虑，因为使用基本类型能够在执行效率以及内存使用两方面提升软件性能。

​	首先，了解一下基本类型在JAVA 虚拟机中的是实现：

```java
public class Foo {
  public static void main(String[] args) {
    boolean 吃过饭没 = 2; // 直接编译的话 javac 会报错
    if (吃过饭没) System.out.println(" 吃了 ");
    if (true == 吃过饭没) System.out.println(" 真吃了 ");
  }
}
 
```

​	在上一节结尾的小问题中，构造了这麽一段代码，它将一个`boolean`类型的局部变量赋值为2。

​	赋值语句后边我设置了两个看似一样的 if 语句。第一个 if 语句，也就是直接判断“吃过饭没”，在它成立的情况下，代码会打印“吃了”。

​	第二个 if 语句，也就是判断“吃过饭没”和 true 是否相等，在它成立的情况下，代码会打印“真吃了”。

​	当然，直接编译这段代码，编译器是会报错的。所以，迂回了一下，采用一个 Java 字节码的汇编工具`asmtool.jar`，直接对字节码进行更改。

​	那么问题就来了：当一个 `boolean` 变量的值是 2 时，它究竟是 true 还是 false 呢？

​	如果跑过这段代码，你会发现，问虚拟机“吃过饭没”，它会回答“吃了”，而问虚拟机“真（==）吃过饭没”，虚拟机则不会回答“真吃了”。

​	那么虚拟机到底吃过没，下面我们来一起分析一下这背后的细节。

#### JAVA虚拟机的`boolean`类型

​	首先，看看JAVA语言规范以及JAVA虚拟机规范是怎末定义`boolean`类型的。

​	JAVA语言规范中，`boolean`类型的值只有两种可能，它们分别用符号`true`和`false`来表示。显然，这两个符号是不能被虚拟机直接使用的。

​	在JAVA虚拟机规范中，`boolean`类型则被映射为`int`类型。具体地说，`true`被映射为整数1，`false`被映射为整数0.这个编码规则约束了JAVA字节码的具体实现。

​	举个例子，对于存储`boolean`数组的字节码，JAVA虚拟机需保证实际存入的值是整数1或者0。

​	JAVA虚拟机规范同时也要求 Java 编译器遵守这个编码规则，并且用整数相关的字节码来实现逻辑运算，以及基于 `boolean` 类型的条件跳转。这样一来，在编译而成的 class 文件中，除了字段和传入参数外，基本看不出 `boolean` 类型的痕迹了。

```assembly
# Foo.main 编译后的字节码
 0: iconst_2       // 我们用 AsmTools 更改了这一指令
 1: istore_1
 2: iload_1
 3: ifeq 14        // 第一个 if 语句，即操作数栈上数值为 0 时跳转 
 6: getstatic java.lang.System.out
 9: ldc " 吃了 "
11: invokevirtual java.io.PrintStream.println
14: iload_1
15: iconst_1
16: if_icmpne 27   // 第二个 if 语句，即操作数栈上两个数值不相同时跳转
19: getstatic java.lang.System.out 
22: ldc " 真吃了 "
24: invokevirtual java.io.PrintStream.println
27: return

```

​	在前面的例子中，第一个 if 语句会被编译成条件跳转字节码 `ifeq`，翻译成人话就是说，如果局部变量“吃过饭没”的值为 0，那么跳过打印“吃了”的语句。

​	而第二个 if 语句则会被编译成条件跳转字节码 `if_icmpne`，也就是说，如果局部变量的值和整数 1 不相等，那么跳过打印“真吃了”的语句。

​	对于 Java 虚拟机来说，它看到的 `boolean` 类型，早已被映射为整数类型。因此，将原本声明为 `boolean` 类型的局部变量，赋值为除了 0、1 之外的整数值，在 Java 虚拟机看来是“合法”的。

​	在我们的例子中，经过编译器编译之后，Java 虚拟机看到的不是在问“吃过饭没”，而是在问“吃过几碗饭”。也就是说，第一个 if 语句变成：你不会一碗饭都没吃吧。第二个 if 语句则变成：你吃过一碗饭了吗。

​	如果我们约定俗成，每人每顿只吃一碗，那么第二个 if 语句还是有意义的。但如果我们打破常规，吃了两碗，那么较真的 Java 虚拟机就会将第二个 if 语句判定为假了。

----

#### JAVA的基本类型

​	除了上面提到的 `boolean` 类型外，Java 的基本类型还包括整数类型 byte、short、char、int 和 long，以及浮点类型 float 和 double。

![02-figure1](./02-figure1.png)

​	JAVA 的基本类型都有对应的值域和默认值。可以看到，byte、short、int、long、float 以及 double 的值域依次扩大，而且前面的值域被后面的值域所包含。因此，从前面的基本类型转换至后面的基本类型，无需强制转换。另外一点值得注意的是，尽管他们的默认值看起来不一样，但在内存中都是 `0`。

​	在这些基本类型中，**`boolean`** 和**`char` **是唯二的无符号类型。在不考虑违反规范的情况下，`boolean` 类型的取值范围是 0 或者 1。char 类型的取值范围则是 [0, 65535]。通常我们可以认定 char 类型的值为非负数。这种特性十分有用，比如说作为数组索引等。

----

#### JAVA基本类型的大小

​	在上一篇中曾经提到，JAVA虚拟机每调用一个JAVA方法，便会创建一个**栈帧**。为了方便理解，这里只讨论解释器使用的**解释栈帧（Interpreted frame）**。

​	这种栈帧有两个主要的组成部分，分别是**局部变量区**，以及**字节码的操作数栈**。这里的局部变量是广义的，除了普遍意义下的局部变量之外，它还包含实例方法的**“this 指针”**以及方法所接收的参数。

​	在 Java 虚拟机规范中，**局部变量区**等价于一个数组，并且可以用正整数来索引。除了 long、double 值需要用两个数组单元来存储之外，其他基本类型以及引用类型的值均占用一个数组单元。

​	也就是说，`boolean`、byte、char、short 这四种类型，在栈上占用的空间和 int 是一样的，和引用类型也是一样的。因此，在 32 位的 `HotSpot` 中，这些类型在栈上将占用 4 个字节；而在 64 位的 HotSpot 中，他们将占 8 个字节。

​	当然，这种情况仅存在于局部变量，而并不会出现在存储于堆中的字段或者数组元素上。对于 byte、char 以及 short 这三种类型的字段或者数组单元，它们在堆上占用的空间分别为一字节、两字节，以及两字节，也就是说，跟这些类型的值域相吻合。

​	**`boolean` 字段**和**`boolean` 数组**则比较特殊。在 HotSpot 中，`boolean` 字段占用一字节，而 `boolean` 数组则直接用 byte 数组来实现。为了保证堆中的 `boolean` 值是合法的，HotSpot 在存储时显式地进行掩码操作，也就是说，只取**最后一位的值**存入 `boolean` 字段或数组中。

​	除了**数据的存储**，还有**数据的加载**；JAVA虚拟机的算术运算几乎全部依赖于**操作数栈**，也就是说需要将堆中的 `boolean`、byte、char 以及 short 加载到**操作数栈**上，而后将栈上的值当成 **int 类型**来运算。

​	对于 `boolean`、char 这两个无符号类型来说，加载伴随着零扩展。举个例子，char 的大小为两个字节。在加载时 char 的值会被复制到 int 类型的低二字节，而高二字节则会用 0 来填充。

​	对于 byte、short 这两个类型来说，加载伴随着**符号扩展**。举个例子，short 的大小为两个字节。在加载时 short 的值同样会被复制到 int 类型的低二字节。如果该 short 值为非负数，即最高位为 0，那么该 int 类型的值的高二字节会用 0 来填充，否则用 1 来填充。
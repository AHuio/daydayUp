---
typora-root-url: ..\image
---

**JVM是如何处理异常的**

----

​	众所周知，异常处理的两大组成要素是**抛出异常和捕获异常**，这两大要素共同实现程序控制流的非正常转移。

​	抛出异常可分为**显式**和**隐式**两种，**显式抛异常**的主体是**应用程序**，它指的是在程序中使用**`throw`**关键字，手动将异常实力抛出。

​	隐式抛异常的主题则是JAVA虚拟机，它指的是JAVA虚拟机在执行过程中，碰到无法继续执行的异常状态，自动抛出异常。比如说，JAVA虚拟机再执行读取数组操作时，发现输入的索引值是负数，故而抛出数组索引越界异常（`ArrayIndexOutOfBoundsException`）。

​	捕获异常则涉及了如下三种代码块 ：

- **`try`**代码块：用来标记需要进行异常监控的代码
- **`catch`**代码块：跟在try代码块之后，用来捕获在try代码中触发的某种指定类型的异常。除了声明所捕异常的类型之外，catch代码块还定义了针对该异常类型的异常处理器。在JAVA中，try代码块后面可以跟着多个catch代码块，来捕获不同类型的异常。JAVA虚拟机会从上至下匹配异常处理器。因此，前面的catch代码块所捕获的异常类型不能覆盖后边的，否则编译器会报错。
- **`finally`**代码块：跟在try代码块和catch代码块之后，用来声明一段必定运行的代码。它的设计初衷是为了避免跳过某些关键的清理代码，例如关闭已经打开的系统资源。

​    在程序正常执行的情况下，`finaly`代码会在`try`代码块之后运行。否则，也就是try代码块触发异常的情况下，如果该异常没有被捕获，`finally`代码块会直接运行，并且在运行之后**重新抛出该异常**。

----

#### 异常的基本概念

​	在JAVA语言规范中，所有的异常都是**`Throwable`**类或者其子类的实例。**`Throwable`**有两大直接子类。第一个是**`Error`**，涵盖程序不应捕获的异常。当程序触发**`Error`**时，它的执行状态已经无法恢复，需要中止线程甚至是中止虚拟机。第二个子类则是**`Exception`**，涵盖程序可能需要捕获并且处理的异常。

![06-figure1](/06-figure1.png)

​	**`Exception`**有一个特殊的子类**`RuntimeException`**，用来表示“程序虽然无法继续执行，但是还能抢救一下”的情况。前边提到的数组索引越界便是其中的一种。

​	**`RuntimeException`**和**`Error`**属于JAVA里的非检查异常（unchecked exception）。其他异常则属于检查异常（checked exception）。在JAVA语法中，所有的检查异常都需要程序显示的捕获，或者在方法声明中用**throws**关键字标注。通常情况下，程序中自定义的异常应为检查异常，以便最大化利用JAVA编译器的编译时检查。
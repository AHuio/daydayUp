**JVM 是如何执行方法调用的？ （上）**

----

#### 重载与重写

​	在JAVA程序里，如果同一个类中出现多个名字相同，并且参数类型相同的方法，那么它就无法通过编译。也就是说，在正常情况下，如果我们想要在同一个类中定义名字相同的方法，那么它们的参数类型必须不同。这些方法之间的关系，称之为**重载**。

​	重载的方法在编译过程中即可完成识别。具体到每一个方法调用，JAVA编译器会根据所传入参数的声明类型（注意与实际类型区分）来选取重载方法。选取的过程分为三个阶段：

- 1、在不考虑对基本类型自动装拆箱（auto-boxing，auto-unboxing），以及可变长参数的情况下选取重载方法。
- 2、如果在第一阶段中没有找到适配的方法，那么在允许自动装拆箱，但不允许可变长参数的情况下选取重载方法。
- 3、如果在第2个阶段中没有找到适配的方法，那么在允许自动装拆箱以及可变长参数的情况下选择重载方法。   

​    如果JAVA编译器在同一个阶段中找到了多个适配的方法，那么它会在其中选择一个最为贴切的，而决定贴切程度的一个关键就是形式参数类型的继承关系。

​	除了同一个类中的方法，**重载**也可以作用于这个类所继承而来的方法。也就是说，如果子类定义了与父类中非私有方法同名的方法，而且这两个方法的**参数类型不同**，那么在子类中，这两个方法同样构成了重载。

​	那么，如果子类定义了与父类中非私有方法同名的方法，而且这两个方法的参数类型相同，那么这两个方法之间又是什么关系呢？

​	如果这两个方法都是静态的，那么子类中方法隐藏了父类中的方法。如果这两个方法都不是静态的，且都不是私有的，那么子类的方法**重写**了父类中的方法。

​	众所周知，JAVA是一门面向对象的编程语言，它的一个重要特性就是多态。而方法的重写，正是多态最重要的一种体现方式；它允许子类在继承父类部分功能的同时，拥有自己独特的行为。

----

#### JVM的静态绑定和动态绑定

​	JAVA虚拟机是怎末识别方法的？

​	JAVA虚拟机识别方法的关键在于**类名、方法名以及方法描述符（method descriptor）**。前面两个就不做过多地解释了，至于**方法描述符**，它是由**方法的参数类型以及返回值类型所构成**。在同一个类中，如果出现多个名字相同且描述符也相同的方法。那么JAVA虚拟机会在类的验证阶段报错。

​	JAVA虚拟机与JAVA语言不用，它并不限制名字与参数类型相同，但返回类型不同的方法出现在同一个类中，对于调用这些方法的字节码来说，由于字节码所附带的方法描述符包含了返回类型，因此JAVA虚拟机能够准确地识别目标方法。

​	JAVA虚拟机中关于方法重载的判定同样基于方法描述符。也就是说，如果子类定义了与父类中非私有、非静态方法同名的方法，那麽只有当这两个方法的参数类型以及返回类型一致，JAVA虚拟机才会判定为重写。

​	由于对**重载方法**的区分在**编译阶段**已经完成，可以认为JAVA虚拟机不存在**重载**的概念。因此，在某些文章里**重载**有时也被称为**静态绑定（static binding）**，或者**编译时多态 （compile-time polymorphism）**；而重写则被称为**动态绑定 （dynamic binding）**。

​	这个说法在JAVA虚拟机语境下并非完全正确。这是因为某个类中的重载方法可能被它的子类所重写，因此JAVA编译器会将对所有非私有实例方法的调用编译为需要动态绑定的类型。

​	确切的说，JAVA虚拟机中的静态绑定指的是在解析时便能够直接识别目标方法的情况，而动态绑定则指的是需要在运行过程中根据调用者的动态类型来识别目标方法的情况。

​	具体来说，JAVA字节码中与调用相关的指令共有五种。

> 1、**`invokestatic`**：用于调用静态方法。
>
> 2、**`invokespecial`**：用于调用私有实例方法、构造器，以及使用super关键字调用父类的实例方法或构造器和所实现接口的默认方法。
>
> 3、**`invokevirtual`**：用于调用非私有实例方法。
>
> 4、**`invokeinterface`**：用于调用接口方法。
>
> 5、**`invokedynamic`**：用于调用动态方法。

```java
interface 客户 {
  boolean isVIP();
}
 
class 商户 {
  public double 折后价格 (double 原价, 客户 某客户) {
    return 原价 * 0.8d;
  }
}

class 奸商 extends 商户 {
  @Override
  public double 折后价格 (double 原价, 客户 某客户) {
    if (某客户.isVIP()) {                         // invokeinterface
      return 原价 * 价格歧视 ();                    // invokestatic
    } else {
      return super. 折后价格 (原价, 某客户);          // invokespecial
    }
  }
  public static double 价格歧视 () {
    // 咱们的杀熟算法太粗暴了，应该将客户城市作为随机数生成器的种子。
    return new Random()                          // invokespecial
           .nextDouble()                         // invokevirtual
           + 0.8d;
  }
}
 
```

​	对于**`invokestatic`**以及**`invokespecial`**而言，JAVA虚拟机能够直接识别具体的目标方法。

​	而对于 **`invokevirtual`** 以及 **`invokeinterface`** 而言，在绝大部分情况下，虚拟机需要在执行过程中，根据调用者的动态类型，来确定具体的目标方法。

​	唯一的例外在于，如果虚拟机能够确定目标方法有且仅有一个，比如说目标方法被标记为 final，那么它可以不通过动态类型，直接确定目标方法。

----

#### 调用指令的符号引用

​	在编译过程中，我们并不知道目标方法的具体内存地址。因此，JAVA编译器会暂时用符号引用来表示该目标方法。这一符号引用包括目标方法所在的类或者接口的名字，以及目标方法的方法名和方法描述符。

​	**符号引用**存储在class文件的常量池中，根据目标方法是否为接口方法，这些引用可分为**接口符号引用**和**非接口符号引用**。

​	对于在使用**符号引用**的字节码前，JAVA虚拟机需要解析这些符号引用，并替换为**实际引用**。

​	对于**非接口符号引用**，假定该符号引用所指向的类为C，则JAVA虚拟机会按照如下步骤进行查找：

- 1、在C中查找符合名字及描述符的方法。
- 2、如果没有找到，在C的父类中继续搜索，直至Object类。
- 3、如果没有找到，在C所直接实现或者间接实现的接口中搜索，这一步骤得到的目标方法必须是**非私有、非静态的**。并且，如果目标方法在间接实现的接口中，则需要满足C与该接口之间没有其他符合条件的目标方法。如果有多个符合条件的目标方法，则任意返回其中一个。

​    从这个 解析算法可以看出，静态方法也可以通过子类来调用。此外，子类的静态方法会**隐藏（注意与重写区分）**父类中的同名、同描述符的静态方法。

​	对于接口符号引用，假定该符号引用所指向的接口为`I`，则JAVA虚拟机会按照如下步骤进行查找：

- 1、在`I`中查找符合名字及描述符的方法。
- 2、如果没有找到，在Object类中的公有实例方法中搜索。
- 3、如果没有找到，则在`I`的超接口中搜索，这一步的搜索结果的要求与非接口符号引用步骤3的要求一致。

​    经过上述的解析步骤之后，**符号引用会被解析成实际引用。对于可以静态绑定的方法调用而言，实际引用是一个指向方法的指针**。对于需要动态绑定的方法调用而言，**实际引用**则是一个**方法表**的索引。

----

#### 总结与实践

​	在JAVA中，方法存在**重载以及重写**的概念，**重载**指的是方法名相同而参数类型不相同的方法之间的关系，**重写**指的是方法名相同并且参数也相同的方法之间的关系。

​	JAVA虚拟机识别方法的方式略有不同，除了方法名和参数类型之外，它还会考虑返回类型。

​	在JAVA虚拟机中，静态绑定指的是在解析时便能够直接识别目标方法的情况，而动态绑定则指的是需要在运行过程中根据调用者的动态类型来识别目标方法的情况。由于JAVA编译器已经区分了**重载**的方法，因此可以认为JAVA虚拟机中不存在重载。

​	在class文件中，JAVA编译器会用符号引用指代目标方法。在执行调用指令前，它所附带的符号引用需要被解析成实际引用。对于可以静态绑定的方法调用而言，实际引用为目标方法的指针。对于需要动态绑定的方法调用而言，实际引用为辅助动态绑定的信息。

​	
---
typora-root-url: ..\image
---

**JAVA虚拟机是如何加载JAVA类的？**

----

​	从class文件到内存中的类，按照先后顺序需要经过**加载、链接、以及初始化**三大步骤。其中，**链接**过程同样需要验证；而内存中的类没有经过初始化，同样不能使用。那么，是否所有的JAVA类都需要经过这几步呢？

​	JAVA语言的类型可以分为两大类：**基本类型 (Primitive types)**和**引用类型 (Reference types)**。在上节中，已经详细讲述了JAVA的基本类型，它们都是由JAVA虚拟机预先定义好的。

​	至于**引用类型**，JAVA将其细分为四种：**类、接口、数组类和泛型参数**。由于**泛型参数**会在编译过程中被擦除，因此JAVA虚拟机实际上只有前三种。在**类、接口和数组类**中，**数组类**是由JAVA虚拟机直接生成的，其他两种则有对应的字节流。

​	说到字节流，最常见的形式要属由JAVA编译器生成的class文件。除此之外，也可以在程序内部直接生成，或者从网络中获取字节流。这些不同形式的字节流，都会被加载到JAVA虚拟机中，成为**类**或者**接口**。

​	无论是直接生成的**数组类**，还是加载的类，JAVA虚拟机都需要对其进行**链接和初始化**。

----

#### 加载

​	加载，是指查找字节流，并且据此创建类的过程。前面提到，对于数组类来说，它并没有对应的字节流。而是由JAVA虚拟机直接生成的。对于其他的类来说，JAVA虚拟机则需要借助**类加载器**来完成查找字节流的过程。

​	JAVA最上层的类加载器叫引导类加载器（启动类加载器），除了引导类加载器之外，其他的类加载器都是**`java.lang.ClassLoader`**的子类，因此有对应的JAVA对象。这些**类加载器**需要先由**另一个类加载器**，比如**引导类加载器**加载至JAVA虚拟机中，方能执行**类加载**。

​	![03-figure1](/03-figure1.png)

​	**JAVA虚拟机的类加载机制是先由最上层的类加载器尝试加载，加载失败再由子加载器处理，又名双亲委派模型。**每当一个类加载器接收到加载请求时，它会先将请求转发给父类加载器。在父类加载器没有找到所请求的类的情况下，该类加载器才会尝试去加载。

​	在**JAVA9之前**，引导类加载器负责加载最为基础、最为重要的类。比如存放在JRE的lib目录下jar包中的类（以及有虚拟机参数 `-Xbootclasspath`指定的类）。处理启动类加载器之外，另外两个重要的类加载器是**扩展类加载器 (Extension class loader) 和 应用类加载器 （Application class loader），**均由JAVA核心类库提供。

​	**扩展类加载器**的父类是引导类加载器，它负责加载相对次要、但又通用的类，比如存放在JRE的`lib/ext`目录下jar包中的类（以及由系统变量`java.ext.dirs`指定的类)。

​	**应用类加载器**的父类加载器则是扩展类加载器，它负责加载应用程序路径下的类。（这里的应用程序路径，便是指虚拟机参数 `-cp/-classpath`、系统变量`java.class.path`或环境变量`CLASSPATH`所指定的路径）。默认情况下，应用程序中包含的类便是由应用类加载器加载的。		

​	**JAVA9**引入了模块系统，并且略微更改了上述的类加载器。**扩展类加载器**被改名为**平台类加载器 (platform class loader)**。JAVA SE中除了少数的几个关键模块，比如说`java.base`是由**引导类加载器加载**之外，其他的模块均由**平台类加载器所加载**。

​	除了由JAVA核心类库提供的类加载器外，也可以使用自己定义的类加载器，来实现特殊的加载方式。比如说，可以对class文件进行加密，加载时再利用自定义的类加载器对其解密。

​	除了加载功能之外，类加载器还提供了命名空间的作用。在JAVA虚拟机中，类的唯一性是由**类加载器实例以及类的全名一同确定的**。即便是同一串字节流。经由不同的类加载器加载，也会得到两个不同的类。在大型应用中，往往可以借助这一特性，来运行同一个类的不同版本。

----

#### 链接

​	链接，是指将创建城的类合并到JAVA虚拟机中，是指能够执行的过程。它可以分为**验证、准备以及解析三个阶段**。

​	**验证**阶段的目的，在于确保被加载的类能够满足JAVA虚拟机的约束条件。通常而言，JAVA编译器生成的类文件必须满足JAVA虚拟机的约束条件。

​	**准备**阶段的目的，则是为被加载类的**静态字段**分配内存。除了分配内存外，部分JAVA虚拟机还会在此阶段构造其他跟类相关的数据结构，比如说**用来实现虚方法的动态绑定的方法表**。

​	在class文件被加载至JAVA虚拟机之前，这个类无法知道其它类及其方法、字段所对应的具体地址，甚至不知道自己方法、字段的地址；因此，每当需要引用这些成员时，JAVA编译器会生成一个**符号引用**。在运行阶段，这个符号引用一般能够无歧义地定位到具体目标上。

​	举例来说，对于一个方法调用，编译器会生成一个包含目标方法所在类的名字、目标方法的名字、接收的参数类型以及返回值类型的**符号引用**，来指代所要调用的方法。

​	**解析**阶段的目的，正是将这些符号引用解析为实际引用。如果符号引用指向一个未被加载的类，或者未被加载类的字段或方法，那么解析将触发这个类的**加载**（**但未必触发这个类的链接以及初始化**）。

​	JAVA虚拟机规范并没有要求在链接过程中完成**解析**。它仅规定了：**如果某些字节码使用了符号引用，那么在执行这些字节码之前，需要完成对这些符号引用的解析**

----

#### 初始化

​	在JAVA代码中，如果要初始化一个静态字段，可以在声明时直接赋值，也可以在静态代码块中对其赋值。

​	如果直接赋值的静态字段被**`final`**所修饰，并且它的类型是**基本类型**或**字符串**时，那么该字段便会被JAVA编译器标记为**常量值（`ConstantValue`）**,其初始化直接由JAVA虚拟机完成。除此之外的**直接赋值操作**，以及所有静态代码中的代码，则会被JAVA编译器至于同一个方法中，并将其命名为**`<clinit>`**。

​	类加载的最后一部是**`初始化`**，便是为标记为常量值的字段赋值，以及执行**`<clinit>`**方法的过程。JAVA虚拟机会通过**加锁**来确保类的**`<clinit>`**方法仅被执行一次。

​	只有当**初始化**完成之后，类才正式成为可执行的状态。

​	那么。类的初始化何时会被触发呢？JVM规范枚举了下述多种触发情况：

```
1.当虚拟机启动时，初始化用户指定的主类；
2.当遇到用以新建目标类实例的 new 指令时，初始化 new 指令的目标类；
3.当遇到调用静态方法的指令时，初始化该静态方法所在的类；
4.当遇到访问静态字段的指令时，初始化该静态字段所在的类；
5.子类的初始化会触发父类的初始化；
6.如果一个接口定义了 default 方法，那么直接实现或者间接实现该接口的类的初始化，会触发该接口的初始化；
7.使用反射 API 对某个类进行反射调用时，初始化这个类；
8.当初次调用 MethodHandle 实例时，初始化该 MethodHandle 指向的方法所在的类。
```

----

#### Question?

​	通过 JVM 参数 -verbose:class 来打印类加载的先后顺序，并且在 LazyHolder 的初始化方法中打印特定字样。在命令行中运行下述指令（不包含提示符 $）：

```shell
$ echo '
public class Singleton {
  private Singleton() {}
  private static class LazyHolder {
    static final Singleton INSTANCE = new Singleton();
    static {
      System.out.println("LazyHolder.<clinit>");
    }
  }
  public static Object getInstance(boolean flag) {
    if (flag) return new LazyHolder[2];
    return LazyHolder.INSTANCE;
  } 
  public static void main(String[] args) { 
    getInstance(true);
    System.out.println("----");
    getInstance(false);
  } 
}' > Singleton.java
$ javac Singleton.java
$ java -verbose:class Singleton
 
```

**问题 1：新建数组（第 11 行）会导致 LazyHolder 的加载吗？会导致它的初始化吗？**

在命令行中运行下述指令（不包含提示符 $）：

```shell
$ java -cp /path/to/asmtools.jar org.openjdk.asmtools.jdis.Main Singleton\$LazyHolder.class > Singleton\$LazyHolder.jasm.1
$ awk 'NR==1,/stack 1/{sub(/stack 1/, "stack 0")} 1' Singleton\$LazyHolder.jasm.1 > Singleton\$LazyHolder.jasm
$ java -cp /path/to/asmtools.jar org.openjdk.asmtools.jasm.Main Singleton\$LazyHolder.jasm
$ java -verbose:class Singleton
```

**问题 2：新建数组会导致 LazyHolder 的链接吗？**
> 参考文章：  
> <https://zhuanlan.zhihu.com/p/164511591>

## mysql的各组件
![](https://pic2.zhimg.com/80/v2-558458f3e0e78ea091d37dd22428a915_1440w.jpg)  

> **mysql**原理图各个组件说明：  
> 1.   **connectors**：  
> 与其他编程语言的sql语句进行交互，如php、java等
> 2. **Management Services & Utilties**：  
> 系统管理和控制工具
> 3. **Connection Pool**:  
> 管理缓冲用户连接，线程处理等需要缓冲的需求  
> 4. **SQL Interface (sql接口)**：  
> 接受用户的sql命令，并且返回用户需要查询的结果。
> 5. **Parser （解析器）**：   
> SQL命令传递到解析器的时候会被解析器验证和解析。  
> **主要功能**：   
> **a.** 将SQL语句分解成数据结构，并将这个结构传递到后续步骤，后面的SQL语句的传递和处理就是基于这个结构的。  
> **b.** 如果在分解构成中遇到错误，那么就说明这个sql语句是不合理的，语句将不会继续执行下去。  
> 6. **Optimizer (查询优化器)**：  
> SQL语句在查询之前会使用查询优化器对查询进行优化(产生多种执行计划,最终数据库会选择最优化的方案去执行,尽快返会结果)   
> 他使用的是“**选取-投影-联接**”策略进行查询。  
> 用一个例子就可以理解：  
> `select uid,name from user where gender = 1;`  
> 这个select 查询先根据where语句进行选取，而不是先将表全部查询出来以后再进行gender过滤;  
> 这个select查询先根据uid和name进行属性投影，而不是将属性全部取出以后再进行过滤;  
> 将这两个查询条件联接起来生成最终查询结果。
> 7. **Cache 和 Buffer （查询缓存）**：  
> 如果查询缓存有命中的查询结果，查询语句就可以直接去查询缓存中取数据。  
> 这个缓存机制是由一系列小缓存组成的。比如表缓存，记录缓存，key缓存，权限缓存等。  
> 8. **Engine （存储引擎）**：  
> 存储引擎是MySql中具体的与文件打交道的子系统。也是Mysql最具有特色的一个地方。  
> Mysql的存储引擎是插件式的。它根据MySql AB公司提供的文件访问层的一个抽象接口来定制一种文件访问机制（这种访问机制就叫存储引擎）。
>

## SQL语句执行过程

​	数据库通产不会被直接使用，而是通过其他编程语言通过SQL语句调用mysql，由mysql处理并返回执行结果。Mysql接收到SQL语句之后，又是如何处理的呢？

​	首先程序的请求会通过mysql的**connectors**与其进行交互，请求结束后，会暂时存放在连接池（connection pool）中并由处理器（Management Services & Utilties）管理。当该请求从等待队列进入处理队列，管理器会将该请求丢给SQL接口（SQL Interface）。SQL接口接收到请求后，它会将请求进行Hash处理并与缓存中的结果进行对比，如果完全匹配则通过缓存直接返回处理结果；否则，需要完整的走一遍流程：

> 1、由SQL接口丢给后面的解释器（**Parser**），解释器会判断SQL语句正确与否，若正确则将其转化为数据结构。
>
> 2、解释器处理完，便来到后面的优化器（**Optimizer**），它会产生多种执行计划,最终数据库会选择最优化的方案去执行,尽快返会结果。
>
> 3、确定最优执行计划后，SQL语句此时便可以交由存储引擎（**Engine**）处理，存储引擎将会到后端的存储设备中取得相应的数据，并原路返回给程序。

**注意点：**

> （1）**如何缓存查询数据**
>
> ​	存储引擎处理完数据，并将数据返回给程序的同时，它还会将一份数据保留在缓存中，以便更快速的处理下一个相同的请求。具体情况是，mysql会将查询的语句、执行的结果等进行**hash**，并保留在**cache**中，等待下次查询。
>
> （2）**buffer与cache的区别**
>
> ​	从mysql的原理图中可以看出，缓存那里实际上有buffer和cache两个，它们之间的区别：**buffer是写缓存，cache是读缓存**。
>
> （3）**如何判断缓存中是否已缓存需要的数据**
>
> ​	这里可能有一个误区，觉得处理SQL语句的时候，为了判断是否已缓存查询结果，会将整个流程走一遍，取得执行结果后再与需要的进行对比，看看是否命中，并以此说，既然不管缓存中有没有缓存到查询内容，都要整个流程走一遍，那缓存的优势在哪？
>
> ​	其实并不是这样，在第一次查询后，mysql便将查询语句以及查询结果进行**hash**处理并保留在缓存中，SQL查询到达之后，对其进行同样的**hash**处理后，将两个hash值进行对照，如果一样，则命中，从缓存中返回查询结果；否则，需要整个流程走一遍。
>
> ​	当数据库中有多个操作需要修改同一数据时，不可避免的会产生数据的脏读。这时就需要数据库具有良好的并发控制能力，这一切在MySQL中都是由**服务器**和**存储引擎**来实现的。
>
> ​	解决并发问题最有效的方案是引入了**锁**的机制，锁在功能上分为**共享锁(shared lock)**和**排它锁(exclusive lock)**即通常说的**读锁**和**写锁**。当一个select语句在执行时可以施加读锁，这样就可以允许其它的select操作进行，因为在这个过程中数据信息是不会被改变的这样就能够提高数据库的运行效率。当需要对数据更新时，就需要施加写锁了，不在允许其它的操作进行，以免产生数据的脏读和幻读。锁同样有粒度大小，有**表级锁(table lock)**和**行级锁(row lock)**，分别在数据操作的过程中完成行的锁定和表的锁定。这些根据不同的存储引擎所具有的特性也是不一样的。
>
> ​	MySQL大多数事务型的存储引擎都不是简单的**行级锁**，基于性能的考虑，他们一般都同时实现了**多版本并发控制(MVCC)**。这一方案也被Oracle等主流的关系数据库采用。它是通过保存数据中某个时间点的**快照**来实现的，这样就保证了每个事务看到的数据都是一致的。详细的实现原理可以参考《高性能MySQL》第三版。

##  事务 （transaction）

 **1、事务**就是一组原子性的SQL语句，可以将这组语句理解为一个工作单元，要麽全部执行，要麽都不执行。在MySQL中可以使用如下的命令操作事务：

```sql
mysql> show variables like 'autocommit';
+---------------+-------+
| Variable_name | Value |
+---------------+-------+
| autocommit    | ON    |
+---------------+-------+
1 row in set, 1 warning (0.00 sec)
```



> start transaction;
>
> select ...
>
> update ...
>
> insert ...
>
> commit;

**注意**：MySQL默认中自动提交是开启的。

**2、事务**具有ACID的特性：

> **原子性(atomicity)**:事务中的所有操作要么全部提交成功，要么全部失败回滚。
> **一致性(consistency)**:数据库总是从一个一致性状态转换到另一个一致性状态。
> **隔离性(isolation)**:一个事务所做的修改在提交之前对其它事务是不可见的。
> **持久性(durability)**:一旦事务提交，其所做的修改便会永久保存在数据库中。

**3、事务的隔离级别：**

在SQL标准中定义了四种隔离级别:

> **READ UNCOMMITTED(读未提交)**：事务中的修改即使未提交也是对其它事务可见
> **READ COMMITTED(读提交)**：事务提交后所做的修改才会被另一个事务看见，可能产生一个事务中两次查询的结果不同。
> **REPEATABLE READ(可重读)**：只有当前事务提交才能看见另一个事务的修改结果。解决了一个事务中两次查询的结果不同的问题。
> **SERIALIZABLE(串行化)**：只有一个事务提交之后才会执行另一个事务。


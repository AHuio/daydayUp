> 参考文章：  
> <https://zhuanlan.zhihu.com/p/164511591>

## mysql的各组件
![](https://pic2.zhimg.com/80/v2-558458f3e0e78ea091d37dd22428a915_1440w.jpg)  

> **mysql**原理图各个组件说明：  
> 1.   **connectors**：  
> 与其他编程语言的sql语句进行交互，如php、java等
> 2. **Management Services & Utilties**：  
> 系统管理和控制工具
> 3. **Connection Pool**:  
> 管理缓冲用户连接，线程处理等需要缓冲的需求  
> 4. **SQL Interface (sql接口)**：  
> 接受用户的sql命令，并且返回用户需要查询的结果。
> 5. **Parser （解析器）**：   
> SQL命令传递到解析器的时候会被解析器验证和解析。  
> **主要功能**：   
> **a.** 将SQL语句分解成数据结构，并将这个结构传递到后续步骤，后面的SQL语句的传递和处理就是基于这个结构的。  
> **b.** 如果在分解构成中遇到错误，那么就说明这个sql语句是不合理的，语句将不会继续执行下去。  
> 6. **Optimizer (查询优化器)**：  
> SQL语句在查询之前会使用查询优化器对查询进行优化(产生多种执行计划,最终数据库会选择最优化的方案去执行,尽快返会结果)   
> 他使用的是“**选取-投影-联接**”策略进行查询。  
> 用一个例子就可以理解：  
> `select uid,name from user where gender = 1;`  
> 这个select 查询先根据where语句进行选取，而不是先将表全部查询出来以后再进行gender过滤;  
> 这个select查询先根据uid和name进行属性投影，而不是将属性全部取出以后再进行过滤;  
> 将这两个查询条件联接起来生成最终查询结果。
> 7. **Cache 和 Buffer （查询缓存）**：  
> 如果查询缓存有命中的查询结果，查询语句就可以直接去查询缓存中取数据。  
> 这个缓存机制是由一系列小缓存组成的。比如表缓存，记录缓存，key缓存，权限缓存等。  
> 8. **Engine （存储引擎）**：  
> 存储引擎是MySql中具体的与文件打交道的子系统。也是Mysql最具有特色的一个地方。  
> Mysql的存储引擎是插件式的。它根据MySql AB公司提供的文件访问层的一个抽象接口来定制一种文件访问机制（这种访问机制就叫存储引擎）。
>

## SQL语句执行过程

​	数据库通产不会被直接使用，而是通过其他编程语言通过SQL语句调用mysql，由mysql处理并返回执行结果。Mysql接收到SQL语句之后，又是如何处理的呢？

​	首先程序的请求会通过mysql的**connectors**与其进行交互，请求结束后，会暂时存放在连接池（connection pool）中并由处理器（Management Services & Utilties）管理。当该请求从等待队列进入处理队列，管理器会将该请求丢给SQL接口（SQL Interface）。SQL接口接收到请求后，它会将请求进行Hash处理并与缓存中的结果进行对比，如果完全匹配则通过缓存直接返回处理结果；否则，需要完整的走一遍流程：

> 1、由SQL接口丢给后面的解释器（**Parser**），解释器会判断SQL语句正确与否，若正确则将其转化为数据结构。
>
> 2、解释器处理完，便来到后面的优化器（**Optimizer**），它会产生多种执行计划,最终数据库会选择最优化的方案去执行,尽快返会结果。
>
> 3、确定最优执行计划后，SQL语句此时便可以交由存储引擎（**Engine**）处理，存储引擎将会到后端的存储设备中取得相应的数据，并原路返回给程序。

**注意点：**

> （1）**如何缓存查询数据**
>
> ​	存储引擎处理完数据，并将数据返回给程序的同时，它还会将一份数据保留在缓存中，以便更快速的处理下一个相同的请求。具体情况是，mysql会将查询的语句、执行的结果等进行**hash**，并保留在**cache**中，等待下次查询。
>
> （2）**buffer与cache的区别**
>
> ​	从mysql的原理图中可以看出，缓存那里实际上有buffer和cache两个，它们之间的区别：**buffer是写缓存，cache是读缓存**。
>
> （3）**如何判断缓存中是否已缓存需要的数据**
>
> ​	这里可能有一个误区，觉得处理SQL语句的时候，为了判断是否已缓存查询结果，会将整个流程走一遍，取得执行结果后再与需要的进行对比，看看是否命中，并以此说，既然不管缓存中有没有缓存到查询内容，都要整个流程走一遍，那缓存的优势在哪？
>
> ​	其实并不是这样，在第一次查询后，mysql便将查询语句以及查询结果进行**hash**处理并保留在缓存中，SQL查询到达之后，对其进行同样的**hash**处理后，将两个hash值进行对照，如果一样，则命中，从缓存中返回查询结果；否则，需要整个流程走一遍。
>
> ​	当数据库中有多个操作需要修改同一数据时，不可避免的会产生数据的脏读。这时就需要数据库具有良好的并发控制能力，这一切在MySQL中都是由**服务器**和**存储引擎**来实现的。
>
> ​	解决并发问题最有效的方案是引入了**锁**的机制，锁在功能上分为**共享锁(shared lock)**和**排它锁(exclusive lock)**即通常说的**读锁**和**写锁**。当一个select语句在执行时可以施加读锁，这样就可以允许其它的select操作进行，因为在这个过程中数据信息是不会被改变的这样就能够提高数据库的运行效率。当需要对数据更新时，就需要施加写锁了，不在允许其它的操作进行，以免产生数据的脏读和幻读。锁同样有粒度大小，有**表级锁(table lock)**和**行级锁(row lock)**，分别在数据操作的过程中完成行的锁定和表的锁定。这些根据不同的存储引擎所具有的特性也是不一样的。
>
> ​	MySQL大多数事务型的存储引擎都不是简单的**行级锁**，基于性能的考虑，他们一般都同时实现了**多版本并发控制(MVCC)**。这一方案也被Oracle等主流的关系数据库采用。它是通过保存数据中某个时间点的**快照**来实现的，这样就保证了每个事务看到的数据都是一致的。详细的实现原理可以参考《高性能MySQL》第三版。

##  事务 （transaction）

 **1、事务**就是一组原子性的SQL语句，可以将这组语句理解为一个工作单元，要麽全部执行，要麽都不执行。在MySQL中可以使用如下的命令操作事务：

```sql
mysql> show variables like 'autocommit';
+---------------+-------+
| Variable_name | Value |
+---------------+-------+
| autocommit    | ON    |
+---------------+-------+
1 row in set, 1 warning (0.00 sec)
```



> start transaction;
>
> select ...
>
> update ...
>
> insert ...
>
> commit;

**注意**：MySQL默认中自动提交是开启的。

**2、事务**具有ACID的特性：

> **原子性(atomicity)**:事务中的所有操作要么全部提交成功，要么全部失败回滚。
> **一致性(consistency)**:数据库总是从一个一致性状态转换到另一个一致性状态。
> **隔离性(isolation)**:一个事务所做的修改在提交之前对其它事务是不可见的。
> **持久性(durability)**:一旦事务提交，其所做的修改便会永久保存在数据库中。

**3、事务的隔离级别：**

在SQL标准中定义了四种隔离级别:

> **READ UNCOMMITTED(读未提交)**：事务中的修改即使未提交也是对其它事务可见
> **READ COMMITTED(读提交)**：事务提交后所做的修改才会被另一个事务看见，可能产生一个事务中两次查询的结果不同。
> **REPEATABLE READ(可重读)**：只有当前事务提交才能看见另一个事务的修改结果。解决了一个事务中两次查询的结果不同的问题。
> **SERIALIZABLE(串行化)**：只有一个事务提交之后才会执行另一个事务。

**4、MySQL查询修改隔离级别：**

```sql
# MySQL版本 8.0.15:
mysql> show variables like 'transaction_isolation';
+-----------------------+-----------------+
| Variable_name         | Value           |
+-----------------------+-----------------+
| transaction_isolation | REPEATABLE-READ |
+-----------------------+-----------------+
1 row in set, 1 warning (0.00 sec)

# 修改隔离级别：
mysql> set transaction_isolation='read-committed';
Query OK, 0 rows affected (0.01 sec)

mysql> show variables like 'transaction_isolation';
+-----------------------+----------------+
| Variable_name         | Value          |
+-----------------------+----------------+
| transaction_isolation | READ-COMMITTED |
+-----------------------+----------------+
1 row in set, 1 warning (0.00 sec)
```

**5、死锁问题：**

两个或多个事务在同一资源上相互占用并请求锁定对方占用的资源，从而导致恶性循环的现象。MySQL的部分存储引擎能够检测到死锁的循环依赖并产生相应的错误。**InnoDB**引擎解决死锁的方案是**将持有最少排它锁的事务进行回滚**。

## MySQL存储引擎及应用方案

```sql
mysql> use mysql;
Database changed
# 在MySQL的sql语句后加上\G，表示将查询结果进行按列打印，可以使每个字段打印到单独的行；即将查到的结构旋转90度变成纵向。
mysql> show table status like 'user'\G
*************************** 1. row ***************************
           Name: user
         Engine: InnoDB
        Version: 10
     Row_format: Dynamic
           Rows: 6
 Avg_row_length: 2730
    Data_length: 16384
Max_data_length: 0
   Index_length: 0
      Data_free: 4194304
 Auto_increment: NULL
    Create_time: 2019-04-12 09:06:12
    Update_time: NULL
     Check_time: NULL
      Collation: utf8_bin
       Checksum: NULL
 Create_options: stats_persistent=0
        Comment: Users and global privileges
1 row in set (0.01 sec)
```

1、MySQL采用插件式的存储引擎架构，可以根据不同的需求为不同的表设置不同的存储引擎，可以通过上面的命令形式显示数据库中表的状态信息，以**user**表为例，显示如下：

> **Name**：显示的是表名
> **Engine**：显示存储引擎，该表存储引擎为MyISAM
> **Row_format**：显示行格式，对于MyISAM有Dynamic、Fixed和**Compressed**三种。非别表示表中有可变的数据类型，表中数据类型为固定的，以及表是压缩表的环境。
> **Rows**：显示表中行数
> **Avg_row_length**：平均行长度（字节）
> **Data_length**：数据长度（字节）
> **Max_data_length**：最大存储数据长度（字节）
> **Data_free**：已分配但未使用的空间，包括删除数据空余出来的空间
> **Auto_increment**：下一个插入行自动增长字段的值
> **Create_time**：表的创建时间
> **Update_time**：表数据的最后修改时间
> **Collation**：表的默认字符集及排序规则
> **Checksum**：如果启用，表示整个表的实时校验和
> **Create_options**：创建表示的一些其它选项
> **Comment**：额外的一些注释信息，根据存储引擎的不同表示的内容也不胫相同。

**2、存储引擎介绍：**

> **InnoDB引擎**： 

1.将数据存储在表空间中，表空间由一系列的数据文件组成，由InnoDB管理；
2.支持每个表的数据和索引存放在单独文件中(innodb_file_per_table)；
3.支持事务，采用MVCC来控制并发，并实现标准的4个事务隔离级别，支持外键；
4.索引基于聚簇索引建立，对于主键查询有较高性能；
5.数据文件的平台无关性，支持数据在不同的架构平台移植；
6.能够通过一些工具支持真正的热备。如XtraBackup等；
7.内部进行自身优化如采取可预测性预读，能够自动在内存中创建hash索引等。

> **MyISAM引擎**： 

1.MySQL5.1中默认，不支持事务和行级锁；
2.提供大量特性如全文索引、空间函数、压缩、延迟更新等；
3.数据库故障后，安全恢复性差；
4.对于只读数据可以忍受故障恢复，MyISAM依然非常适用；
5.日志服务器的场景也比较适用，只需插入和数据读取操作；
6.不支持单表一个文件，会将所有的数据和索引内容分别存在两个文件中；
7.MyISAM对整张表加锁而不是对行，所以不适用写操作比较多的场景；
8.支持索引缓存不支持数据缓存。

> **Archive引擎**： 

1.只支持insert和select操作；
2.缓存所有的写数据并进行压缩存储，支持行级锁但不支持事务；
3.适合高速插入和数据压缩，减少IO操作，适用于日志记录和归档服务器。

> **Blackhole引擎**： 

1.没有实现任何存储机制，会将插入的数据进行丢弃，但会存储二进制日志；
2.会在一些特殊需要的复制架构的环境中使用。

> **CSV引擎**： 

1.可以打开CSV文件存储的数据，可以将存储的数据导出，并利用excel打开；
2.可以作为一种数据交换的机制，同样经常使用。

> **Memory引擎**：

1.将数据在内存中缓存，不消耗IO；
2.存储数据速度较快但不会被保留，一般作为临时表的存储被使用。

> **Federated引擎**： 

能够访问远程服务器上的数据的存储引擎。能够建立一个连接连到远程服务器。

> **Mrg_MyISAM引擎**： 

将多个MYISAM表合并为一个。本身并不存储数据，数据存在MyISAM表中间。

> **NDB集群引擎**： 

MySQL Cluster专用。

**3、第三方存储引擎：**

> **1.OLTP类**： 

**XtraDB**：InnoDB的改进版本。
**PBXT**：类似InnoDB，但提供引擎级别的复制和外键约束，适当支持SSD存储。
**TokuDB(开源)**：支持分形树索引结构，支持海量数据的分析。

> 2.**列式存储引擎**：MySQL默认是面向行的存储 

**Infobright**: 支持数十TB的数据量，为数据分析和数据仓库设计的。数据高度压缩。
**InfiniDB**:可以在一组集群间做分布式查询，有商业版但没有典型应用案例。

> 3.**社区存储引擎**： 

**Aria**：解决MyISAM崩溃安全恢复问题，并能够进行数据缓存。
**Groona**: 全文索引引擎。
**QQGraph**: 由Open query研发支持图操作，比如查找两点间最短距离。
**SphinxSE**: 该引擎为Sphinx全文索引搜索服务器提供SQL接口。
**Spider**: 支持sharding并能够基于分片实现并列查询。
**VPForMySQL**: 支持垂直分区。

> 4.**存储引擎选取参考因素** 

**4.1.是否有事务需求**
 如果需要事务支持最好选择InnoDB或者XtraDB，如果主要是select和insert操作MyISAM比较合适，一般使用日志型的应用。
**4.2.备份操作需求**
如果能够关闭服务器进行备份，那么该因素可以忽略，如果需要在线进行热备份，则InnoDB引擎是一个不错的选择。
**4.3.故障恢复需求**
在对恢复要求比较好的场景中推荐使用InnoDB，因为MyISAM数据损坏概率比较大而且恢复速度比较慢。
**4.4.性能上的需求**
有些业务需求只有某些特定的存储引擎才能够满足，如地理空间索引也只有MyISAM引擎支持。所以在应用架构需求环境中也需要管理员折衷考虑，当然从各方面比较而言，InnoDB引擎还是默认应该被推荐使用的。

> 5.**表引擎转换方法** 

**5.1.直接修改**

**5.2.备份修改**
利用mysqldump备份工具将数据导出，修改create table语句中的存储引擎选项。注意修改的同时修改表名。
**5.3.创建插入**

